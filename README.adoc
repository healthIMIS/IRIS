:toc: macro

# image:logo/iris-logo.png[width=100] IRIS System

IRIS stands for "Integration of Remote systems into Infection control Software" and is intended to be the central point of mediation between the various contact, event and guest tracking apps on the one hand and the infection control software (e.g. SORMAS) in the health departments on the other.

This repository is used to manage the development and source code of IRIS.

NOTE: The IRIS system is work in progress. If you are interested or have questions please reach out to us.

toc::[]

////
== Concept

There is a concept written in German which describes the IRIS system: https://github.com/healthIMIS/IRIS-Concept/releases/latest[Last release of the concept]
////

== IRIS System

There are three services in the IRIS system:

- One zentral server (`public-server`) which provides a REST API for the citizen apps and receives the apps' data.
- One zentral service (`location-service`) which provides a REST API for the location apps and which builds and maintains an index of connected locations.
- A service on the health department's side (`client-sormas-sidecar`),which retrieves the data from the public server, decrypts it and makes it available for the front end of the health department. If SORMAS is available, this also feeds the data into the department's SORMAS and generally takes care of communication with SORMAS.

The services are Spring Boot based applications exposing RESTful APIs and running without a user interface.

These are standard Maven projects and just be imported in any IDE. For convenience, enable the <<localDev,`localDev` Maven profile>> so that running the services from your IDE does not need to access a database, but uses H2 in-memory. <<lombok,Note the use of lombok!>>

Further components are:

- A simple service as demo of a location app, which registrate locations and answers to data request for one of this locations.
- A simple CLI application for tests and demonstration (`dummy-app`).
- The client library for SORMAS' REST-API (`sormas-api-client`).

=== Quickstart

Run the services.

[source, bash]
----
$ git clone git@github.com:healthIMIS/IRIS.git iris <1>

$ cd iris <2>
$ ./mvnw spring-boot:run -PlocalDev -am -pl iris-public-server <3>

# in a secound console
$ cd iris <2>
$ ./mvnw spring-boot:run -PlocalDev -am -pl iris-location-service <4>

# in a third console
$ cd iris <2>
$ ./mvnw spring-boot:run -PlocalDev -am -pl iris-app-api-demo <5>

# in a fourth console
$ cd iris <2>
$ ./mvnw spring-boot:run -PlocalDev -am -pl iris-client-sormas-sidecar <6>
----
<1> Clone the repository.
<2> Switch to the root directory.
<3> Run the server with an in-memory database.
    * Public server uses port *8443* by default
<4> Run the location service with an in-memory database.
    * Location service uses port *8080* by default
<5> Run the app demo.
    * App demo uses port *8091* by default
<6> Run the client backend with an in-memory database.
    * Client backend uses port *8092* by default

NOTE: Some of the projects in the Quickstart guide also build dependencies. This is good for a quick start, but is not necessary for every build run.

==== Startup-Script

You may use the following startup-script for Ubuntu Desktop. Be aware, that for other OS you might have to change the 3rd line. Put this script one folder higher then this repository. If you have also cloned the iris-client-frontend, you can start it with the `--fe` parameter. Make shure, that you are using java 11 and that you run `mvn clear` (and `npm install` for FE) after switching branches.

[source, bash]
----
#!/bin/bash

tab="gnome-terminal --tab -- bash -c "
if [[ $* == *--keep* ]]
then
  end=";bash" #;bash
else
  echo "Tabs will close on ctrl-c. Use --keep to prevent this."
  end=""
fi

$tab"cd IRIS && ./mvnw spring-boot:run -PlocalDev -am -pl iris-public-server$end"
$tab"cd IRIS && sleep 5 && ./mvnw spring-boot:run -PlocalDev -am -pl iris-location-service$end"
$tab"cd IRIS && sleep 10 && ./mvnw spring-boot:run -PlocalDev -am -pl iris-app-api-demo$end"

$tab"cd IRIS && sleep 15 && ./mvnw spring-boot:run -PlocalDev -am -pl iris-client-sormas-sidecar$end"
if [[ $* == *--fe* ]]
then
  $tab"cd iris-client-frontend && sleep 15 && npm run serve$end"
else
  echo "Use --fe to also start the frontend."
fi

exit 0
----

==== Dummy App

There is a small Java CLI application as dummy citizen app in the folder `iris-dummy-app` for test and demonstration suppose. This app uses the public API of IRIS, read data requests for a code and put data submissions. For use, the public server must be running!

[source, bash]
----
$ cd iris/iris-dummy-app <1>
$ ./mvnw package <2>
$ java -jar target/iris-dummy-app-0.0.1-SNAPSHOT-jar-with-dependencies.jar <3>
----
<1> Switch to the dummy app project.
<2> Build the app as Jar with all dependencies.
<3> Run the application in a command line. With the parameter `-h` you get a help output.

==== SORMAS

To work with SORMAS you should clone it from https://github.com/hzi-braunschweig/SORMAS-Project and look at https://github.com/hzi-braunschweig/SORMAS-Project/blob/development/sormas-cargoserver/README.md

=== Maven profiles

[width="100%",cols="1a,9a"]
|====================
| [[localDev]] localDev | Includes H2 database driver as dependency and activates the `dev` Spring profile group and the `local` Spring profile.

NOTE: This profile is activated automaticly if there a file application-local.properties under src/main/resources.
|====================

[[profiles]]
=== Spring profiles

Activate the needed profile(s) by setting the `spring.profiles.active` property respective parameter or the `SPRING_PROFILES_ACTIVE` environment variable.

==== Profile groups

[width="100%",cols="1a,9a"]
|====================
| dev | h2_db, dev_env, local
| dev_psql | psql_compose_db, dev_env
| prod | prod_db
|====================

==== Profiles

[width="100%",cols="1a,9a"]
|====================
| local | Exclusively local profile which is not checked into the Git repository. Can be used to set special settings (e.g. work against a locally installed database). If the profile file `application-local.properties` exist, the <<localDev,Maven profile `localDev`>> is activated for easy local execution.
| h2_db | H2 in-memory database and H2 Console
    
NOTE: The <<sample_data,sample data>> are inserted at server startup.

| psql_compose_db | Configuration for the Postgres database at localhost started with the Docker-Compose: `iris/infrastructure/docker-compose.yml`
    
NOTE: The database is cleaned and the <<sample_data,sample data>> are inserted at server startup.

| prod_db | Configuration for the production database, where most settings are likely to be made via the respective environment.

| dev_env | Some additional configurations for execution during development (e.g. debug logging).

| docker | Configuration for the Docker image with Postgres database at host postgres. This is intended for use with Docker-Compose: `iris/infrastructure/docker-compose_with-servers.yml`
|====================

[[postgres]]
=== PostgreSQL Database

There is a Docker-Compose configuration (`infrastructure/docker-compose.yml`) which provides a Postgres db and a pgAdmin via Docker. 

DB:: 
    - login = postgres:postgres; 
    - hostname in Docker = postgres
    - port on host = 5433
    - databases = iris_public + iris_client
    - Docker volume = psqldata_iris

pgAdmin::
    - login = postgres@healthIMIS.de:postgres
    - port on host = 5555
    
=== Run with Docker

You can build Docker images for the services and run this with Docker.

[source, bash]
----
$ # preparation
$ cd iris/infrastructure <1>
$ cp iris-sormas.env.example iris-sormas.env <2>
$ nano iris-sormas.env <2>

$ cd .. <3>
$ ./mvnw package spring-boot:build-image -DskipTests <4>
$ docker-compose -f infrastructure/docker-compose-servers.yml up -d <5>
----
<1> Switch to the infrastructure directory of the iris workspace.
<2> Copy the example of the iris-sormas.env and edit this. Insert the username and password of the IRIS user in your SORMAS test instance.
<3> Switch back to the root directory of the IRIS workspace.
<4> Build the libraries and the images of all services.
<5> Run the Postgres db, the pgAdmin, the public server and the client service with Docker-Compose.
    * Postgres DB <<postgres,as above>>
    * Public server uses port *8443* by default

=== Libraries

The services are based on the following open source projects:

- Spring Boot 2.4
- Spring MVC
- Spring Data
- https://flywaydb.org[Flyway] – for database migration
- https://projectlombok.org[Project Lombok] – for low level code generation
- https://www.vavr.io/[Vavr] – for a better more functional programming style

[[lombok]]
IMPORTANT: Make sure you have the Lombok plugin installed in your IDE so that your code can compile correctly.

== Encryption of the data to be transmitted (contact data)

In order to be not limited in the amount of data, a hybrid encryption with symmetric encryption of the data and asymmetric encryption of the symmetric key is used for the encryption of the contact data.

1. The apps and applications get the public key of the health department as a 4096-bit RSA key from the IRIS+ server. This key is base64-encoded in the Private Enhanced Mail (PEM) format.
2. The app generates a 256-bit AES key.
3. With this key the data is encrypted (algorithm: AES).
4. The AES key must be encrypted with the public RSA key of the health department. (algorithm: RSA with Optimal Asymmetric Encryption Padding (OAEP))
5. The encrypted AES key and the encrypted content must be transmitted base64 encoded.

=== Schematic sequence

```
pubKeyEncryption = publicKeyFromPem(givenPublicKey);
contentKey = generateAESKey();

encrypted = contentKey.encrypt(content);
keyEncrypted = pubKeyEncryption.encrypt(contentKey, "RSA/NONE/OAEPWithSHA3-256AndMGF1Padding");

dataToTransport = base64Encode(encrypted);
keyToTransport = base64Encode(keyEncrypted);
```

== Development 
=== Java parts

We use *Java 11* and the following code style. 

==== Eclipse
https://github.com/iris-gateway/IRIS/tree/main/infrastructure/eclipse-code-formatter.xml[infrastructure/eclipse-code-formatter.xml] +
https://github.com/iris-gateway/IRIS/tree/main/infrastructure/eclipse.importorder[infrastructure/eclipse.importorder]

==== Import order

* static imports, wild card used from the first declaration
* `+*+` - all unmatched imports
* `java.…`
* `javax.–`
* `org.…`
* `com.…`

For non-static imports we switch to `+*+` imports after the 10th import.
For static ones we always use `+*+` ones.

==== Blank lines

Use blank lines to group pieces of code logically: variable initializations go together, followed by the method invocations that use those variables.
There's no hard rule here.
It's just nice to be able to identify different steps in the execution order.

For blocks (if clauses, methods) we start with a blank line if the subsequent code is longer than a single line:

[source, java]
----
void someLongMethod() {

  // First statement
  // Second statement
}

VS.

void someOneLineMethod() {
  // Single-line statement
}
----

Symmetric blocks usually also use a blank line on the end to clearly separate the blocks' content from the outer instruction.
Again, the single line rule applies, here, too.

[source, java]
----
if (…) {
  // Single line instruction
} else {
  // Single line instruction
}

but

if (…) {

  // Multi-line instruction
  // Multi-line instruction

} else {

  // Multi-line instruction
  // Multi-line instruction
}
----

The intermediate lines surrounding the `…} else {…` make it easier to see where the block flips.

In general, for if-else-clauses, prefer the ternary expression (`condition ? if-true : if-false`) over an if block.
That creates incentives to rather extract the statements to be executed in either and make the overall expression readable.
If the overall expression gets so long it would line break, it's nice to read if the three parts are each brought onto a single line:

[source, java]
----
Object someMethod(…) {

  return condition
    ? if-true-do-this
    : else-do-that;
}
----
