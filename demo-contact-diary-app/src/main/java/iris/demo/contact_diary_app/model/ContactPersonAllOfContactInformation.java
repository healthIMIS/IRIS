/*
 * IRIS-Gateway API
 * ### Encryption of the data to be transmitted (contact data) In order to be not limited in the amount of data, a hybrid encryption with symmetric encryption of the data and asymmetric encryption of the symmetric key is used for the encryption of the contact data.    1. The apps and applications get the public key of the health department as a 4096-bit RSA key from the IRIS+ server. This key is base64-encoded similar to the Private Enhanced Mail (PEM) format but without key markers (-----BEGIN PUBLIC KEY----- / -----END PUBLIC KEY-----).   2. The app generates a 256-bit AES key.   3. The data is encrypted with this key (algorithm: AES/CBC/PKCS5Padding and 16 byte IV)   4. IV bytes are prepended to the cipher text. Those merged bytes represent the encrypted content.   5. The AES key must be encrypted with the public RSA key of the health department. (algorithm: RSA with Optimal Asymmetric Encryption Padding (OAEP) \"RSA/ECB/OAEPWITHSHA-256ANDMGF1PADDING\")   6. The encrypted AES key and the encrypted content must be transmitted base64 encoded.    #### Schematic sequence    ```   pubKeyEncryption = publicKeyFromBase64(givenPublicKey);   contentKey = generateAESKey();   iv = generateRandomBytes(16);    encrypted = contentKey.encrypt(content, \"AES/CBC/PKCS5Padding\", iv);   keyEncrypted = pubKeyEncryption.encrypt(contentKey, \"RSA/NONE/OAEPWithSHA3-256AndMGF1Padding\");    submissionDto.encryptedData = base64Encode(concat(iv,encrypted));   submissionDto.secret = base64Encode(keyEncrypted);   ``` 
 *
 * The version of the OpenAPI document: 0.2.0
 * Contact: jens.kutzsche@gebea.de
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package iris.demo.contact_diary_app.model;

import java.time.LocalDate;
import java.util.Objects;

/**
 * Additional informations about the contact(s) with the queried person.
 */
public class ContactPersonAllOfContactInformation {
	public static final String SERIALIZED_NAME_FIRST_CONTACT_DATE = "firstContactDate";
	private LocalDate firstContactDate;

	public static final String SERIALIZED_NAME_LAST_CONTACT_DATE = "lastContactDate";
	private LocalDate lastContactDate;

	public static final String SERIALIZED_NAME_CONTACT_CATEGORY = "contactCategory";
	private ContactCategory contactCategory;

	public static final String SERIALIZED_NAME_BASIC_CONDITIONS = "basicConditions";
	private String basicConditions;

	public ContactPersonAllOfContactInformation firstContactDate(LocalDate firstContactDate) {

		this.firstContactDate = firstContactDate;
		return this;
	}

	/**
	 * Get firstContactDate
	 * 
	 * @return firstContactDate
	 **/

	public LocalDate getFirstContactDate() {
		return firstContactDate;
	}

	public void setFirstContactDate(LocalDate firstContactDate) {
		this.firstContactDate = firstContactDate;
	}

	public ContactPersonAllOfContactInformation lastContactDate(LocalDate lastContactDate) {

		this.lastContactDate = lastContactDate;
		return this;
	}

	/**
	 * Get lastContactDate
	 * 
	 * @return lastContactDate
	 **/

	public LocalDate getLastContactDate() {
		return lastContactDate;
	}

	public void setLastContactDate(LocalDate lastContactDate) {
		this.lastContactDate = lastContactDate;
	}

	public ContactPersonAllOfContactInformation contactCategory(ContactCategory contactCategory) {

		this.contactCategory = contactCategory;
		return this;
	}

	/**
	 * Get contactCategory
	 * 
	 * @return contactCategory
	 **/

	public ContactCategory getContactCategory() {
		return contactCategory;
	}

	public void setContactCategory(ContactCategory contactCategory) {
		this.contactCategory = contactCategory;
	}

	public ContactPersonAllOfContactInformation basicConditions(String basicConditions) {

		this.basicConditions = basicConditions;
		return this;
	}

	/**
	 * Informations about the basic conditions such as: from, to, place, inside|outside, mask yes|no, distance
	 * &gt;&#x3D;|&lt; 1,5m, ventilated yes|no, remarks.
	 * 
	 * @return basicConditions
	 **/

	public String getBasicConditions() {
		return basicConditions;
	}

	public void setBasicConditions(String basicConditions) {
		this.basicConditions = basicConditions;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}
		ContactPersonAllOfContactInformation contactPersonAllOfContactInformation = (ContactPersonAllOfContactInformation) o;
		return Objects.equals(this.firstContactDate, contactPersonAllOfContactInformation.firstContactDate) &&
				Objects.equals(this.lastContactDate, contactPersonAllOfContactInformation.lastContactDate) &&
				Objects.equals(this.contactCategory, contactPersonAllOfContactInformation.contactCategory) &&
				Objects.equals(this.basicConditions, contactPersonAllOfContactInformation.basicConditions);
	}

	@Override
	public int hashCode() {
		return Objects.hash(firstContactDate, lastContactDate, contactCategory, basicConditions);
	}

	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("class ContactPersonAllOfContactInformation {\n");
		sb.append("    firstContactDate: ").append(toIndentedString(firstContactDate)).append("\n");
		sb.append("    lastContactDate: ").append(toIndentedString(lastContactDate)).append("\n");
		sb.append("    contactCategory: ").append(toIndentedString(contactCategory)).append("\n");
		sb.append("    basicConditions: ").append(toIndentedString(basicConditions)).append("\n");
		sb.append("}");
		return sb.toString();
	}

	/**
	 * Convert the given object to string with each line indented by 4 spaces (except the first line).
	 */
	private String toIndentedString(Object o) {
		if (o == null) {
			return "null";
		}
		return o.toString().replace("\n", "\n    ");
	}

}
