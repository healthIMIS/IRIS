/*
 * IRIS-Gateway API
 * ### Encryption of the data to be transmitted (contact data) In order to be not limited in the amount of data, a hybrid encryption with symmetric encryption of the data and asymmetric encryption of the symmetric key is used for the encryption of the contact data.    1. The apps and applications get the public key of the health department as a 4096-bit RSA key from the IRIS+ server. This key is base64-encoded similar to the Private Enhanced Mail (PEM) format but without key markers (-----BEGIN PUBLIC KEY----- / -----END PUBLIC KEY-----).   2. The app generates a 256-bit AES key.   3. The data is encrypted with this key (algorithm: AES/CBC/PKCS5Padding and 16 byte IV)   4. IV bytes are prepended to the cipher text. Those merged bytes represent the encrypted content.   5. The AES key must be encrypted with the public RSA key of the health department. (algorithm: RSA with Optimal Asymmetric Encryption Padding (OAEP) \"RSA/ECB/OAEPWITHSHA-256ANDMGF1PADDING\")   6. The encrypted AES key and the encrypted content must be transmitted base64 encoded.    #### Schematic sequence    ```   pubKeyEncryption = publicKeyFromBase64(givenPublicKey);   contentKey = generateAESKey();   iv = generateRandomBytes(16);    encrypted = contentKey.encrypt(content, \"AES/CBC/PKCS5Padding\", iv);   keyEncrypted = pubKeyEncryption.encrypt(contentKey, \"RSA/NONE/OAEPWithSHA3-256AndMGF1Padding\");    submissionDto.encryptedData = base64Encode(concat(iv,encrypted));   submissionDto.secret = base64Encode(keyEncrypted);   ``` 
 *
 * The version of the OpenAPI document: 0.2.0
 * Contact: jens.kutzsche@gebea.de
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package iris.demo.contact_diary_app.model;

import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * A collection of guests who attended a queried event or location in the queried time. This data must be encrypted with
 * the key of health department from DataRequest.keyOfHealthDepartment and must be encoded with Base64!
 * (&#x60;dataToTransport&#x60; in the general description of the API.)
 */
public class GuestList {
	public static final String SERIALIZED_NAME_GUESTS = "guests";
	private List<Guest> guests = new ArrayList<>();

	public static final String SERIALIZED_NAME_DATA_PROVIDER = "dataProvider";
	private GuestListDataProvider dataProvider;

	public static final String SERIALIZED_NAME_ADDITIONAL_INFORMATION = "additionalInformation";
	private String additionalInformation;

	public static final String SERIALIZED_NAME_START_DATE = "startDate";
	private Instant startDate;

	public static final String SERIALIZED_NAME_END_DATE = "endDate";
	private Instant endDate;

	public GuestList guests(List<Guest> guests) {

		this.guests = guests;
		return this;
	}

	public GuestList addGuestsItem(Guest guestsItem) {
		this.guests.add(guestsItem);
		return this;
	}

	/**
	 * Get guests
	 * 
	 * @return guests
	 **/

	public List<Guest> getGuests() {
		return guests;
	}

	public void setGuests(List<Guest> guests) {
		this.guests = guests;
	}

	public GuestList dataProvider(GuestListDataProvider dataProvider) {

		this.dataProvider = dataProvider;
		return this;
	}

	/**
	 * Get dataProvider
	 * 
	 * @return dataProvider
	 **/

	public GuestListDataProvider getDataProvider() {
		return dataProvider;
	}

	public void setDataProvider(GuestListDataProvider dataProvider) {
		this.dataProvider = dataProvider;
	}

	public GuestList additionalInformation(String additionalInformation) {

		this.additionalInformation = additionalInformation;
		return this;
	}

	/**
	 * Additional informations about the guest list and the event or location.
	 * 
	 * @return additionalInformation
	 **/

	public String getAdditionalInformation() {
		return additionalInformation;
	}

	public void setAdditionalInformation(String additionalInformation) {
		this.additionalInformation = additionalInformation;
	}

	public GuestList startDate(Instant startDate) {

		this.startDate = startDate;
		return this;
	}

	/**
	 * Start date/time of attendance for this guest list.
	 * 
	 * @return startDate
	 **/

	public Instant getStartDate() {
		return startDate;
	}

	public void setStartDate(Instant startDate) {
		this.startDate = startDate;
	}

	public GuestList endDate(Instant endDate) {

		this.endDate = endDate;
		return this;
	}

	/**
	 * End date/time of attendance for this guest list.
	 * 
	 * @return endDate
	 **/

	public Instant getEndDate() {
		return endDate;
	}

	public void setEndDate(Instant endDate) {
		this.endDate = endDate;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}
		GuestList guestList = (GuestList) o;
		return Objects.equals(this.guests, guestList.guests) &&
				Objects.equals(this.dataProvider, guestList.dataProvider) &&
				Objects.equals(this.additionalInformation, guestList.additionalInformation) &&
				Objects.equals(this.startDate, guestList.startDate) &&
				Objects.equals(this.endDate, guestList.endDate);
	}

	@Override
	public int hashCode() {
		return Objects.hash(guests, dataProvider, additionalInformation, startDate, endDate);
	}

	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("class GuestList {\n");
		sb.append("    guests: ").append(toIndentedString(guests)).append("\n");
		sb.append("    dataProvider: ").append(toIndentedString(dataProvider)).append("\n");
		sb.append("    additionalInformation: ").append(toIndentedString(additionalInformation)).append("\n");
		sb.append("    startDate: ").append(toIndentedString(startDate)).append("\n");
		sb.append("    endDate: ").append(toIndentedString(endDate)).append("\n");
		sb.append("}");
		return sb.toString();
	}

	/**
	 * Convert the given object to string with each line indented by 4 spaces (except the first line).
	 */
	private String toIndentedString(Object o) {
		if (o == null) {
			return "null";
		}
		return o.toString().replace("\n", "\n    ");
	}

}
